<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Шашки (диагональ+вертикаль+горизонталь) - человек vs AI</title>
  <style>
    :root {
      --light: #f2efe6;
      --dark: #6a4b3a;
      --sel: #2aa9ff;
      --hint: #35d07f;
      --cap: #ff6b6b;
      --panel: #ffffff;
      --muted: #666;
      --board-color: #8B4513;
      --cell-border: #5D4037;
      --diag-mode: #ff9800;
      --ortho-mode: #4caf50;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #f6f6f6;
    }
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      padding: 12px;
      display: grid;
      gap: 14px;
      grid-template-columns: 1fr 340px 300px;
    }
    @media (max-width: 1200px) {
      .wrap {
        grid-template-columns: 1fr 340px;
      }
      .notation {
        grid-column: 1 / -1;
        max-height: 200px;
      }
    }
    @media (max-width: 980px) {
      .wrap {
        grid-template-columns: 1fr;
        padding: 10px;
      }
      .side {
        max-height: none;
      }
      .notation {
        grid-column: 1;
      }
    }
    .board-container {
      position: relative;
      width: min(90vw, 560px);
      margin: 0 auto;
    }
    .board {
      width: 100%;
      aspect-ratio: 1/1;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 24px rgba(0,0,0,.14);
      user-select: none;
      touch-action: manipulation;
      background: var(--board-color);
      border: 2px solid var(--cell-border);
    }
    .coords {
      position: absolute;
      color: #5D4037;
      font-size: 16px;
      font-weight: bold;
      z-index: 1;
      user-select: none;
    }
    .coord-file {
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      width: 30px;
      text-align: center;
    }
    .coord-rank {
      top: 50%;
      left: -24px;
      transform: translateY(-50%);
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .sq {
      display: grid;
      place-items: center;
      position: relative;
      background: var(--board-color);
      border: 1px solid var(--cell-border);
      box-sizing: border-box;
    }
    .sq:hover {
      filter: brightness(1.15);
      cursor: pointer;
      background-color: #9C6B4D;
    }
    .sq.sel {
      outline: 4px solid var(--sel);
      outline-offset: -4px;
      z-index: 2;
    }
    .sq.hint {
      outline: 4px solid var(--hint);
      outline-offset: -4px;
      z-index: 1;
    }
    .sq.capHint::after {
      content: "";
      position: absolute;
      inset: 10%;
      border: 3px dashed var(--cap);
      border-radius: 10px;
      opacity: .9;
      pointer-events: none;
      z-index: 1;
    }
    .piece {
      width: 72%;
      height: 72%;
      border-radius: 999px;
      display: grid;
      place-items: center;
      box-shadow: 0 8px 16px rgba(0,0,0,.22);
      z-index: 3;
      position: relative;
    }
    .piece.white {
      background: radial-gradient(circle at 30% 30%, #fff, #d8d8d8);
      border: 2px solid #ccc;
    }
    .piece.black {
      background: radial-gradient(circle at 30% 30%, #444, #0f0f0f);
      border: 2px solid #222;
    }
    /* Дамки — с контрастными кружками в центре */
    .piece.king {
        position: relative;
    }
    .piece.king::before {
        content: "";
        position: absolute;
        width: 40%;
        height: 40%;
        border-radius: 50%;
        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .piece.white.king::before {
        background: radial-gradient(circle at 30% 30%, #333, #000);
        border: 1px solid #111;
    }
    .piece.black.king::before {
        background: radial-gradient(circle at 30% 30%, #fff, #e0e0e0);
        border: 1px solid #ccc;
    }
    .piece.protected::after {
      content: "";
      position: absolute;
      top: 2px;
      right: 2px;
      width: 9px;
      height: 9px;
      background: rgba(76, 175, 80, 0.75);
      border-radius: 50%;
    }
    .side {
      background: var(--panel);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.08);
      display: grid;
      gap: 12px;
      align-content: start;
    }
    .notation {
      background: var(--panel);
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,.08);
      display: flex;
      flex-direction: column;
      max-height: 560px;
    }
    .notation-header {
      font-weight: bold;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 2px solid #eee;
      font-size: 15px;
      color: #333;
    }
    .moves-container {
      flex: 1;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
    }
    .move-row {
      display: grid;
      grid-template-columns: 40px 1fr 1fr;
      gap: 8px;
      padding: 4px 6px;
      border-radius: 4px;
      margin-bottom: 2px;
    }
    .move-row:nth-child(even) {
      background: #f9f9f9;
    }
    .move-row.current {
      background: #e3f2fd;
      font-weight: bold;
    }
    .move-number {
      color: #666;
      text-align: right;
      font-weight: normal;
    }
    .move-white, .move-black {
      color: #333;
    }
    .move-capture {
      color: #e53935;
      font-weight: bold;
    }
    @media (max-width: 1000px) {
      .side {
        max-height: 600px;
        overflow-y: auto;
        padding-right: 10px;
      }
    }
    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      border: 0;
      padding: 10px 12px;
      border-radius: 10px;
      background: #111;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
      font-size: 14px;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    button.secondary {
      background: #e9e9e9;
      color: #111;
    }
    button:disabled {
      opacity: .55;
      cursor: not-allowed;
    }
    .status {
      padding: 10px 12px;
      border-radius: 12px;
      background: #f1f1f1;
      border-left: 4px solid var(--sel);
      font-size: 14px;
    }
    .small {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
    details {
      background: #fafafa;
      border-radius: 12px;
      padding: 10px 12px;
      border-left: 4px solid var(--hint);
      font-size: 13px;
    }
    details > summary {
      cursor: pointer;
      font-weight: 700;
      padding: 4px 0;
      font-size: 14px;
    }
    details > summary:hover {
      color: #333;
    }
    .capture-mode {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
      font-size: 13px;
    }
    .mode-badge {
      padding: 4px 8px;
      border-radius: 6px;
      font-weight: bold;
    }
    .diag-mode {
      background: var(--diag-mode);
      color: white;
    }
    .ortho-mode {
      background: var(--ortho-mode);
      color: white;
    }
    .mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .mode-btn {
      flex: 1;
      padding: 10px;
      border: 2px solid #ddd;
      background: #f5f5f5;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      font-weight: 600;
      transition: all 0.2s;
      font-size: 13px;
    }
    .mode-btn.active {
      background: #2aa9ff;
      color: white;
      border-color: #2aa9ff;
    }
    .mode-btn:hover:not(.active) {
      background: #e9e9e9;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div>
    <div class="board-container">
      <div id="board" class="board" aria-label="Доска"></div>
    </div>
  </div>
  <aside class="side">
    <div class="mode-selector">
      <div id="modeHumanVsAI" class="mode-btn active">Человек vs AI</div>
      <div id="modeComputerVsHuman" class="mode-btn">Компьютер vs Человек</div>
    </div>
    <div class="status" id="status">Загрузка...</div>
    <div id="captureMode" class="capture-mode" style="display:none;"></div>
    <div class="row">
      <button id="newBtn">Новая игра</button>
      <button id="undoBtn" class="secondary" disabled>Отменить (ход человека)</button>
      <button id="hintBtn" class="secondary">Подсказка</button>
    </div>
    <div class="row">
      <button id="difficultyEasy" class="secondary" style="background:#4caf50;">Легко</button>
      <button id="difficultyMedium" class="secondary" style="background:#ff9800;">Средне</button>
      <button id="difficultyHard" class="secondary" style="background:#f44336;">Сложно</button>
    </div>
    <details open>
      <summary>Правила игры</summary>
      <div class="small" style="margin-top:8px">
        o Обычная шашка: ходит в <b>3</b> направления (вперёд-лево, вперёд-вправо, вперёд-вертикально).<br>
        o Обычная шашка бьёт в <b>8</b> направлениях: 4 диагонали + вертикаль вверх/вниз + горизонталь влево/вправо.<br>
        o Дамка: ходит как <b>ферзь</b> (8 направлений).<br>
        o Шашкам можно бить:<br>
          &nbsp;&nbsp;1 вариант - <b>только по диагоналям</b>;<br>
          &nbsp;&nbsp;2 вариант - <b>только по ортогоналям</b>.<br>
        o В одном ходе (цепочке) <b>нельзя смешивать</b> варианты взятия.<br>
        o Взятие обязательно.<br>
        o Начальная расстановка: по 24 шашки (8×3) с каждой стороны.<br>
        o Ходить можно по всем клеткам (все клетки одного цвета).
      </div>
    </details>
  </aside>
  <div class="notation">
    <div class="notation-header">Ходы игры</div>
    <div id="movesContainer" class="moves-container">
      <!-- Ходы будут добавляться здесь -->
    </div>
  </div>
</div>

<script>
const SIZE = 8;

const state = {
  board: null,
  turn: "w",
  selected: null,
  legalMoves: [],
  hints: new Map(),
  busy: false,
  history: [],
  aiDepth: 3,
  captureMode: null,
  transpositionTable: new Map(),
  gameMode: "humanVsAI",
  moveHistory: [],
  moveNumber: 1,
  currentMoveIndex: -1
};

function cloneBoard(board) {
  return board.map(row => row.map(cell => cell ? ({...cell}) : null));
}
function inBounds(r,c) {
  return r>=0 && r<SIZE && c>=0 && c<SIZE;
}
function forwardDir(player) {
  return player==="w" ? -1 : +1;
}
function boardHash(board){
  let hash = "";
  for (let r=0; r<SIZE; r++){
    for (let c=0; c<SIZE; c++){
      const p = board[r][c];
      hash += p ? `${p.p}${p.k ? 'k' : 'm'}` : "__";
    }
  }
  return hash;
}

// Функции для нотации
function toAlgebraic(r, c) {
  const file = String.fromCharCode('a'.charCodeAt(0) + c);
  const rank = SIZE - r; // A1 внизу слева, H8 вверху справа
  return file + rank;
}

function fromAlgebraic(alg) {
  const file = alg.charCodeAt(0) - 'a'.charCodeAt(0);
  const rank = SIZE - parseInt(alg.charAt(1));
  return { r: rank, c: file };
}

function getMoveNotation(move, board) {
  const from = move.from;
  const to = move.path[move.path.length - 1];
  const piece = board[from.r][from.c];
  
  let notation = toAlgebraic(from.r, from.c);
  notation += move.captures.length > 0 ? ':' : '-';
  notation += toAlgebraic(to.r, to.c);
  
  // Проверяем превращение в дамку
  const lastPos = move.path[move.path.length - 1];
  const pieceAfterMove = applyMove(board, move)[lastPos.r][lastPos.c];
  if (piece && !piece.k && pieceAfterMove && pieceAfterMove.k) {
    notation += '(дамка)';
  }
  
  return notation;
}

function addMoveToHistory(move, board, player) {
  const notation = getMoveNotation(move, board);
  
  if (player === 'w') {
    // Белые ходят в новом ходе
    state.moveHistory.push({
      number: state.moveNumber,
      white: notation,
      black: null
    });
    state.currentMoveIndex = state.moveHistory.length - 1;
  } else {
    // Черные ходят в существующем ходе
    if (state.moveHistory.length > 0) {
      state.moveHistory[state.moveHistory.length - 1].black = notation;
    } else {
      // Если белые не ходили (в начале игры против AI)
      state.moveHistory.push({
        number: state.moveNumber,
        white: null,
        black: notation
      });
      state.currentMoveIndex = 0;
    }
    state.moveNumber++;
  }
  
  renderNotation();
}

function renderNotation() {
  const container = document.getElementById('movesContainer');
  container.innerHTML = '';
  
  state.moveHistory.forEach((moveObj, index) => {
    const row = document.createElement('div');
    row.className = 'move-row';
    if (index === state.currentMoveIndex) {
      row.classList.add('current');
    }
    
    const numberSpan = document.createElement('span');
    numberSpan.className = 'move-number';
    numberSpan.textContent = moveObj.number + '.';
    
    const whiteSpan = document.createElement('span');
    whiteSpan.className = 'move-white';
    if (moveObj.white) {
      whiteSpan.textContent = moveObj.white;
      if (moveObj.white.includes(':')) {
        whiteSpan.classList.add('move-capture');
      }
    } else {
      whiteSpan.textContent = '...';
    }
    
    const blackSpan = document.createElement('span');
    blackSpan.className = 'move-black';
    if (moveObj.black) {
      blackSpan.textContent = moveObj.black;
      if (moveObj.black.includes(':')) {
        blackSpan.classList.add('move-capture');
      }
    } else {
      blackSpan.textContent = '';
    }
    
    row.appendChild(numberSpan);
    row.appendChild(whiteSpan);
    row.appendChild(blackSpan);
    container.appendChild(row);
  });
  
  // Прокручиваем к последнему ходу
  container.scrollTop = container.scrollHeight;
}

function renderBoardCoordinates() {
  const boardContainer = document.querySelector('.board-container');
  
  // Удаляем старые координаты
  const oldCoords = boardContainer.querySelectorAll('.coords');
  oldCoords.forEach(coord => coord.remove());
  
  // Добавляем буквы для вертикалей (файлов) - внизу
  for (let c = 0; c < SIZE; c++) {
    const coord = document.createElement('div');
    coord.className = 'coords coord-file';
    coord.textContent = String.fromCharCode('A'.charCodeAt(0) + c);
    // Располагаем под доской, ниже границы
    const cellWidth = 100 / SIZE;
    coord.style.left = `${(c * cellWidth) + (cellWidth / 2)}%`;
    boardContainer.appendChild(coord);
  }
  
  // Добавляем цифры для горизонталей (рядов) - слева
  for (let r = 0; r < SIZE; r++) {
    const coord = document.createElement('div');
    coord.className = 'coords coord-rank';
    coord.textContent = (SIZE - r).toString();
    // Располагаем слева от доски
    const cellHeight = 100 / SIZE;
    coord.style.top = `${(r * cellHeight) + (cellHeight / 2)}%`;
    boardContainer.appendChild(coord);
  }
}

const boardEl = document.getElementById("board");
const statusEl = document.getElementById("status");
const captureModeEl = document.getElementById("captureMode");
const newBtn = document.getElementById("newBtn");
const undoBtn = document.getElementById("undoBtn");
const hintBtn = document.getElementById("hintBtn");
const diffEasy = document.getElementById("difficultyEasy");
const diffMedium = document.getElementById("difficultyMedium");
const diffHard = document.getElementById("difficultyHard");
const modeHumanVsAI = document.getElementById("modeHumanVsAI");
const modeComputerVsHuman = document.getElementById("modeComputerVsHuman");

function cellKey(r,c) {
  return `${r},${c}`;
}

function initialBoard(){
  const b = Array.from({length: SIZE}, () => Array(SIZE).fill(null));
  for (let r=0; r<3; r++) {
    for (let c=0; c<SIZE; c++) {
      b[r][c] = { p:"b", k:false };
    }
  }
  for (let r=SIZE-3; r<SIZE; r++) {
    for (let c=0; c<SIZE; c++) {
      b[r][c] = { p:"w", k:false };
    }
  }
  return b;
}

function render(){
  boardEl.innerHTML = "";
  state.captureMode = null;
  captureModeEl.style.display = "none";
  
  // Сначала рендерим клетки
  for (let r=0; r<SIZE; r++){
    for (let c=0; c<SIZE; c++){
      const sq = document.createElement("div");
      sq.className = "sq";
      sq.dataset.r = r;
      sq.dataset.c = c;

      if (state.selected && state.selected.r===r && state.selected.c===c) {
        sq.classList.add("sel");
      }
      if (state.hints.has(cellKey(r,c))) {
        sq.classList.add("hint");
      }

      const mv = state.hints.get(cellKey(r,c));
      if (mv && mv.captures.length>0) {
        sq.classList.add("capHint");
        if (mv.mode && !state.captureMode) {
          state.captureMode = mv.mode;
          captureModeEl.innerHTML = `
            <span>Тип взятия:</span>
            <span class="mode-badge ${mv.mode}-mode">
              ${mv.mode === 'diag' ? 'Диагональное' : 'Ортогональное'}
            </span>
          `;
          captureModeEl.style.display = "flex";
        }
      }

      const piece = state.board[r][c];
      if (piece){
        const p = document.createElement("div");
        p.className = "piece " + (piece.p==="w" ? "white" : "black") + (piece.k ? " king" : "");
        
        if (isProtected(state.board, r, c, piece.p)) {
          p.classList.add("protected");
        }
        
        sq.appendChild(p);
      }

      boardEl.appendChild(sq);
    }
  }
  
  // Затем координаты рядом с доской
  renderBoardCoordinates();

  const outcome = getOutcome(state.board, state.turn);
  if (outcome.over){
    statusEl.innerHTML = `<b>Игра окончена.</b> ${outcome.message}`;
  } else {
    let playerName = "";
    if (state.gameMode === "humanVsAI") {
      playerName = state.turn==="w" ? "человек (белые)" : "AI (чёрные)";
    } else {
      playerName = state.turn==="w" ? "компьютер (белые)" : "человек (чёрные)";
    }
    
    const hintText = state.selected ? 
      `<span class="small">Выделена шашка. Кликните на подсвеченную клетку для хода</span>` :
      `<span class="small">Выберите свою шашку для хода</span>`;
    
    statusEl.innerHTML =
      `<b>Ход: ${playerName}</b><br>` +
      `<span class="small">Возможных ходов: ${state.legalMoves.length}</span><br>` +
      hintText;
  }
}

function updateLegalMoves(){
  state.legalMoves = getLegalMoves(state.board, state.turn);
  state.selected = null;
  state.hints.clear();
  
  if ((state.gameMode === "humanVsAI" && state.turn === "b") ||
      (state.gameMode === "computerVsHuman" && state.turn === "w")) {
    aiTurn();
  } else {
    render();
  }
}

boardEl.addEventListener("click", (e) => {
  if (state.busy) return;
  const target = e.target.closest(".sq");
  if (!target) return;

  const r = Number(target.dataset.r);
  const c = Number(target.dataset.c);

  const outcome = getOutcome(state.board, state.turn);
  if (outcome.over) return;
  
  if (state.gameMode === "humanVsAI" && state.turn !== "w") return;
  if (state.gameMode === "computerVsHuman" && state.turn !== "b") return;

  const mv = state.hints.get(cellKey(r,c));
  if (mv){
    state.history = [cloneBoard(state.board)];
    undoBtn.disabled = false;

    // Добавляем ход в историю перед применением
    addMoveToHistory(mv, state.board, state.turn);
    
    state.board = applyMove(state.board, mv);
    
    state.turn = state.turn === "w" ? "b" : "w";
    state.selected = null;
    state.hints.clear();
    updateLegalMoves();
    return;
  }

  const humanColor = state.gameMode === "humanVsAI" ? "w" : "b";
  const piece = state.board[r][c];
  if (!piece || piece.p !== humanColor) return;

  state.selected = {r,c};
  state.hints.clear();

  const movesFromHere = state.legalMoves.filter(m => m.from.r===r && m.from.c===c);
  for (const m of movesFromHere){
    const to = m.path[m.path.length-1];
    state.hints.set(cellKey(to.r,to.c), m);
  }
  render();
});

newBtn.addEventListener("click", () => startGame());
undoBtn.addEventListener("click", () => {
  if (state.history.length){
    state.board = cloneBoard(state.history[0]);
    state.turn = state.gameMode === "humanVsAI" ? "w" : "b";
    state.history = [];
    undoBtn.disabled = true;
    
    // Удаляем последний ход из истории
    if (state.moveHistory.length > 0) {
      const lastMove = state.moveHistory[state.moveHistory.length - 1];
      if (lastMove.black) {
        // Если черные сходили, удаляем весь ход
        state.moveHistory.pop();
        state.moveNumber--;
      } else if (lastMove.white) {
        // Если только белые сходили, удаляем их ход
        state.moveHistory.pop();
      }
      state.currentMoveIndex = state.moveHistory.length - 1;
      renderNotation();
    }
    
    updateLegalMoves();
  }
});

hintBtn.addEventListener("click", () => {
  const humanColor = state.gameMode === "humanVsAI" ? "w" : "b";
  if (state.turn !== humanColor || state.busy) return;
  
  const { move } = minimax(state.board, humanColor, 2, -Infinity, Infinity);
  if (move) {
    state.selected = move.from;
    state.hints.clear();
    const to = move.path[move.path.length-1];
    state.hints.set(cellKey(to.r, to.c), move);
    render();
  }
});

modeHumanVsAI.addEventListener("click", () => {
  if (state.gameMode === "humanVsAI") return;
  state.gameMode = "humanVsAI";
  modeHumanVsAI.classList.add("active");
  modeComputerVsHuman.classList.remove("active");
  startGame();
});

modeComputerVsHuman.addEventListener("click", () => {
  if (state.gameMode === "computerVsHuman") return;
  state.gameMode = "computerVsHuman";
  modeComputerVsHuman.classList.add("active");
  modeHumanVsAI.classList.remove("active");
  startGame();
});

diffEasy.addEventListener("click", () => {
  state.aiDepth = 2;
  diffEasy.style.background = '#4caf50';
  diffMedium.style.background = '#e9e9e9';
  diffHard.style.background = '#e9e9e9';
});

diffMedium.addEventListener("click", () => {
  state.aiDepth = 3;
  diffEasy.style.background = '#e9e9e9';
  diffMedium.style.background = '#ff9800';
  diffHard.style.background = '#e9e9e9';
});

diffHard.addEventListener("click", () => {
  state.aiDepth = 4;
  diffEasy.style.background = '#e9e9e9';
  diffMedium.style.background = '#e9e9e9';
  diffHard.style.background = '#f44336';
});

function mkMove(fromR, fromC, path, captures, mode){
  return { from:{r:fromR,c:fromC}, path, captures, mode };
}

function getLegalMoves(board, player){
  const captures = [];
  const normals = [];

  for (let r=0; r<SIZE; r++){
    for (let c=0; c<SIZE; c++){
      const piece = board[r][c];
      if (!piece || piece.p !== player) continue;

      const caps = piece.k
        ? genKingCaptures(board, r, c, player)
        : genManCaptures(board, r, c, player);

      captures.push(...caps);

      if (caps.length === 0){
        const ms = piece.k
          ? genKingMoves(board, r, c)
          : genManMoves(board, r, c, player);
        normals.push(...ms);
      }
    }
  }

  return captures.length ? captures : normals;
}

function genManMoves(board, r, c, player){
  const res = [];
  const dr = forwardDir(player);

  for (const dc of [-1, +1]){
    const nr = r+dr, nc = c+dc;
    if (inBounds(nr,nc) && board[nr][nc]===null){
      res.push(mkMove(r,c,[{r:nr,c:nc}],[],null));
    }
  }
  
  const nr = r+dr, nc = c;
  if (inBounds(nr,nc) && board[nr][nc]===null){
    res.push(mkMove(r,c,[{r:nr,c:nc}],[],null));
  }
  
  return res;
}

function genKingMoves(board, r, c){
  const res = [];
  const dirs = [
    [-1,-1],[-1,+1],[+1,-1],[+1,+1],
    [-1, 0],[+1, 0],[ 0,-1],[ 0,+1]
  ];
  for (const [dr,dc] of dirs){
    let nr=r+dr, nc=c+dc;
    while (inBounds(nr,nc) && board[nr][nc]===null){
      res.push(mkMove(r,c,[{r:nr,c:nc}],[],null));
      nr += dr; nc += dc;
    }
  }
  return res;
}

function genManCaptures(board, r, c, player){
  const startPiece = board[r][c];
  if (!startPiece) return [];
  const res = [];

  const dirs8 = [
    [-1,-1],[-1,+1],[+1,-1],[+1,+1],
    [-1, 0],[+1, 0],
    [ 0,-1],[ 0,+1]
  ];

  function dfs(b, cr, cc, piece, path, caps, mode){
    let any = false;
    const curPiece = maybePromote(piece, cr, player);

    if (curPiece.k){
      const steps = genKingCaptureSteps(b, cr, cc, player, mode);
      for (const step of steps){
        any = true;
        const nextMode = mode || step.mode;
        const nb = applyQueenCaptureStep(b, cr, cc, step, curPiece);
        dfs(nb.board, step.to.r, step.to.c, nb.movedPiece, 
            [...path, step.to], [...caps, step.cap], nextMode);
      }
    } else {
      for (const [dr,dc] of dirs8){
        const dirMode = (dr!==0 && dc!==0) ? "diag" : "ortho";
        if (mode && dirMode !== mode) continue;

        const mr = cr+dr, mc = cc+dc;
        const lr = cr+2*dr, lc = cc+2*dc;
        if (!inBounds(lr,lc) || !inBounds(mr,mc)) continue;

        const mid = b[mr][mc];
        if (mid && mid.p !== player && b[lr][lc]===null){
          any = true;
          const nb = cloneBoard(b);
          nb[cr][cc] = null;
          nb[mr][mc] = null;
          const moved = {...curPiece};
          nb[lr][lc] = moved;
          dfs(nb, lr, lc, moved, [...path,{r:lr,c:lc}], 
              [...caps,{r:mr,c:mc}], dirMode);
        }
      }
    }

    if (!any && caps.length>0){
      res.push(mkMove(r,c,path,caps,mode));
    }
  }

  dfs(cloneBoard(board), r, c, {...startPiece}, [], [], null);
  return res;
}

function genKingCaptures(board, r, c, player){
  const startPiece = board[r][c];
  if (!startPiece) return [];
  const res = [];

  function dfs(b, cr, cc, piece, path, caps, mode){
    let any = false;
    const steps = genKingCaptureSteps(b, cr, cc, player, mode);
    
    for (const step of steps){
      any = true;
      const nextMode = mode || step.mode;
      const nb = applyQueenCaptureStep(b, cr, cc, step, piece);
      dfs(nb.board, step.to.r, step.to.c, nb.movedPiece, 
          [...path, step.to], [...caps, step.cap], nextMode);
    }

    if (!any && caps.length>0){
      res.push(mkMove(r,c,path,caps,mode));
    }
  }

  dfs(cloneBoard(board), r, c, {...startPiece}, [], [], null);
  return res;
}

function genKingCaptureSteps(board, r, c, player, mode){
  const dirs8 = [
    [-1,-1],[-1,+1],[+1,-1],[+1,+1],
    [-1, 0],[+1, 0],[ 0,-1],[ 0,+1]
  ];

  const steps = [];

  for (const [dr,dc] of dirs8){
    const dirMode = (dr!==0 && dc!==0) ? "diag" : "ortho";
    if (mode && dirMode !== mode) continue;

    let nr = r+dr, nc = c+dc;
    let seenEnemy = null;

    while (inBounds(nr,nc)){
      const cell = board[nr][nc];

      if (cell === null){
        if (seenEnemy){
          steps.push({ cap: seenEnemy, to:{r:nr,c:nc}, mode: dirMode });
        }
      } else {
        if (cell.p === player) break;
        if (seenEnemy) break;
        seenEnemy = { r:nr, c:nc };
      }

      nr += dr; nc += dc;
    }
  }

  return steps;
}

function applyQueenCaptureStep(board, fromR, fromC, step, piece){
  const nb = cloneBoard(board);
  nb[fromR][fromC] = null;
  nb[step.cap.r][step.cap.c] = null;
  const movedPiece = {...piece};
  nb[step.to.r][step.to.c] = movedPiece;
  return { board: nb, movedPiece };
}

function maybePromote(piece, r, player){
  if (piece.k) return piece;
  const lastRow = (player==="w") ? 0 : SIZE-1;
  if (r === lastRow) return { ...piece, k:true };
  return piece;
}

function applyMove(board, move){
  const nb = cloneBoard(board);
  const from = move.from;
  const piece = nb[from.r][from.c];
  nb[from.r][from.c] = null;

  for (const cap of move.captures) nb[cap.r][cap.c] = null;

  const last = move.path[move.path.length-1];
  let moved = {...piece};
  moved = maybePromote(moved, last.r, moved.p);

  nb[last.r][last.c] = moved;
  return nb;
}

function countPieces(board, player){
  let n=0;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++){
    const p = board[r][c];
    if (p && p.p===player) n++;
  }
  return n;
}

function getOutcome(board, turn){
  const moves = getLegalMoves(board, turn);
  const wCount = countPieces(board, "w");
  const bCount = countPieces(board, "b");
  if (wCount === 0) return { over:true, message:"Победили чёрные." };
  if (bCount === 0) return { over:true, message:"Победили белые." };
  if (moves.length === 0){
    return { over:true, message: turn==="w" ? "У белых нет ходов. Победили чёрные." : "У чёрных нет ходов. Победили белые." };
  }
  return { over:false, message:"" };
}

function evaluate(board){
  let score = 0;
  
  const mobilityB = getLegalMoves(board, "b").length;
  const mobilityW = getLegalMoves(board, "w").length;
  
  let centerControlB = 0;
  let centerControlW = 0;
  
  for (let r=0; r<SIZE; r++){
    for (let c=0; c<SIZE; c++){
      const pc = board[r][c];
      if (!pc) continue;
      
      const isCenter = (r >= 2 && r <= 5 && c >= 2 && c <= 5);
      const isProtectedPos = isProtected(board, r, c, pc.p);
      
      let pieceValue = pc.k ? 8 : 3;
      
      if (pc.k) {
        pieceValue += centerScore(r, c);
      }
      
      if (isCenter) pieceValue += 0.5;
      if (isProtectedPos) pieceValue += 0.3;
      
      if (pc.p === "b") {
        score += pieceValue;
        if (isCenter) centerControlB++;
      } else {
        score -= pieceValue;
        if (isCenter) centerControlW++;
      }
    }
  }
  
  score += 0.08 * (mobilityB - mobilityW);
  score += 0.05 * (centerControlB - centerControlW);
  
  return score;
}

function centerScore(r, c){
  const centerR = Math.abs(r - 3.5);
  const centerC = Math.abs(c - 3.5);
  const distFromCenter = Math.sqrt(centerR*centerR + centerC*centerC);
  return (7 - distFromCenter) * 0.1;
}

function isProtected(board, r, c, player){
  const dirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
  let protectCount = 0;
  
  for (const [dr, dc] of dirs){
    const nr = r + dr;
    const nc = c + dc;
    if (inBounds(nr, nc) && board[nr][nc] && board[nr][nc].p === player){
      protectCount++;
    }
  }
  
  return protectCount >= 2;
}

function sortMoves(moves, board, player){
  return moves.sort((a, b) => {
    const scoreA = moveHeuristic(a, board, player);
    const scoreB = moveHeuristic(b, board, player);
    return scoreB - scoreA;
  });
}

function moveHeuristic(move, board, player){
  let score = 0;
  
  score += move.captures.length * 5;
  
  const lastPos = move.path[move.path.length-1];
  const piece = board[move.from.r][move.from.c];
  
  if (piece && !piece.k) {
    const lastRow = (player==="w") ? 0 : SIZE-1;
    if (lastPos.r === lastRow) score += 3;
  }
  
  if (isProtected(board, lastPos.r, lastPos.c, player)) {
    score += 0.5;
  }
  
  const isCenter = (lastPos.r >= 2 && lastPos.r <= 5 && lastPos.c >= 2 && lastPos.c <= 5);
  if (isCenter) score += 0.3;
  
  return score;
}

function minimax(board, player, depth, alpha, beta){
  const hash = boardHash(board) + player + depth;
  if (state.transpositionTable.has(hash)){
    return state.transpositionTable.get(hash);
  }
  
  const outcome = getOutcome(board, player);
  if (outcome.over){
    let score;
    if (outcome.message.includes("чёрные")) score = 9999 + depth;
    else if (outcome.message.includes("белые")) score = -9999 - depth;
    else score = evaluate(board);
    
    const result = { score, move:null };
    state.transpositionTable.set(hash, result);
    return result;
  }
  
  if (depth === 0) {
    const score = evaluate(board);
    const result = { score, move:null };
    state.transpositionTable.set(hash, result);
    return result;
  }

  let moves = getLegalMoves(board, player);
  
  if (player === "b") {
    moves = sortMoves(moves, board, player);
  }
  
  if (moves.length === 0) {
    const score = evaluate(board);
    const result = { score, move:null };
    state.transpositionTable.set(hash, result);
    return result;
  }

  const isMax = (player==="b");
  let bestMove = moves[0];

  if (isMax){
    let bestScore = -Infinity;
    for (const mv of moves){
      const nb = applyMove(board, mv);
      const res = minimax(nb, "w", depth-1, alpha, beta);
      if (res.score > bestScore){ 
        bestScore = res.score; 
        bestMove = mv; 
      }
      alpha = Math.max(alpha, bestScore);
      if (beta <= alpha) break;
    }
    const result = { score: bestScore, move: bestMove };
    state.transpositionTable.set(hash, result);
    return result;
  } else {
    let bestScore = Infinity;
    for (const mv of moves){
      const nb = applyMove(board, mv);
      const res = minimax(nb, "b", depth-1, alpha, beta);
      if (res.score < bestScore){ 
        bestScore = res.score; 
        bestMove = mv; 
      }
      beta = Math.min(beta, bestScore);
      if (beta <= alpha) break;
    }
    const result = { score: bestScore, move: bestMove };
    state.transpositionTable.set(hash, result);
    return result;
  }
}

async function aiTurn(){
  const outcome = getOutcome(state.board, state.turn);
  if (outcome.over){ 
    render(); 
    return; 
  }

  state.busy = true;
  render();
  await new Promise(r => setTimeout(r, 100));
  
  state.transpositionTable.clear();
  
  const aiColor = state.gameMode === "humanVsAI" ? "b" : "w";
  const { move } = minimax(state.board, aiColor, state.aiDepth, -Infinity, Infinity);
  
  if (move) {
    // Добавляем ход AI в историю
    addMoveToHistory(move, state.board, aiColor);
    
    state.board = applyMove(state.board, move);
    state.turn = aiColor === "w" ? "b" : "w";
  }

  state.busy = false;
  state.history = [];
  undoBtn.disabled = true;
  updateLegalMoves();
}

function startGame(){
  state.board = initialBoard();
  if (state.gameMode === "humanVsAI") {
    state.turn = "w";
  } else {
    state.turn = "w";
  }
  state.selected = null;
  state.hints.clear();
  state.history = [];
  state.transpositionTable.clear();
  state.moveHistory = [];
  state.moveNumber = 1;
  state.currentMoveIndex = -1;
  undoBtn.disabled = true;
  renderNotation();
  updateLegalMoves();
}
startGame();
</script>
</body>
</html>