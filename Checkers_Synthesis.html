<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>–®–∞—à–∫–∏ 7x8 - –ú–æ–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
  <style>
    :root {
      --board-color: #8B4513;
      --cell-border: #5D4037;
      --sel: #2aa9ff;
      --hint: #35d07f;
      --cap: #ff6b6b;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 12px;
      touch-action: manipulation;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 16px;
      padding: 12px;
      /* ‚Üê –±—ã–ª–æ 16px */
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
    }

    .status {
      text-align: center;
      margin-bottom: 12px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 12px;
      border-left: 4px solid var(--sel);
    }

    .status h2 {
      font-size: 18px;
      color: #333;
      margin-bottom: 4px;
    }

    .status-info {
      font-size: 14px;
      color: #666;
    }

    .controls {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }



    .btn {
      padding: 14px 8px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      touch-action: manipulation;
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn-primary {
      background: #4a6cf7;
      color: white;
    }

    .btn-secondary {
      background: #e9ecef;
      color: #333;
    }

    .btn-danger {
      background: #ff4757;
      color: white;
    }

    .btn-success {
      background: #2ed573;
      color: white;
    }

    .board-container {
      position: relative;
      width: 100%;
      margin: 0 auto;
    }

    .board {
      width: 100%;
      max-width: 400px;
      margin: 0 auto;
      aspect-ratio: 7/8;
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
      touch-action: none;
      background: var(--board-color);
      border: 3px solid var(--cell-border);
    }

    .sq {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      background: var(--board-color);
      border: 1px solid var(--cell-border);
      cursor: pointer;
      user-select: none;
    }

    .sq:active {
      background-color: #9C6B4D;
    }

    .sq.sel {
      outline: 3px solid var(--sel);
      outline-offset: -3px;
      z-index: 2;
    }

    .sq.hint {
      outline: 3px solid var(--hint);
      outline-offset: -3px;
      z-index: 1;
    }

    .sq.capHint::after {
      content: "";
      position: absolute;
      inset: 12%;
      border: 2px dashed var(--cap);
      border-radius: 10px;
      opacity: 0.9;
      pointer-events: none;
      z-index: 1;
    }

    .piece {
      width: 72%;
      height: 72%;
      border-radius: 50%;
      box-shadow:
        0 4px 12px rgba(0, 0, 0, 0.25),
        inset 0 2px 4px rgba(255, 255, 255, 0.3);
      position: relative;
      z-index: 3;
    }

    .piece.white {
      background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0);
      border: 2px solid #d4d4d4;
    }

    .piece.black {
      background: radial-gradient(circle at 30% 30%, #555555, #111111);
      border: 2px solid #333;
    }

    .piece.king::before {
      content: "";
      position: absolute;
      width: 36%;
      height: 36%;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 2px solid;
    }

    .piece.white.king::before {
      background-color: #000;
      border-color: #000;
    }

    .piece.black.king::before {
      background-color: #fff;
      border-color: #fff;
    }

    .rules-panel {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
    }

    .rules-toggle {
      width: 100%;
      padding: 14px;
      background: #4a6cf7;
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .rules-content {
      font-size: 14px;
      line-height: 1.5;
      color: #555;
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .rules-content.show {
      max-height: 300px;
    }

    .rules-content ul {
      padding-left: 20px;
      margin: 12px 0;
    }

    .rules-content li {
      margin-bottom: 8px;
    }

    .ai-info {
      background: #e3f2fd;
      border-radius: 12px;
      padding: 12px;
      margin-top: 12px;
      font-size: 13px;
      line-height: 1.4;
      color: #1565c0;
      border-left: 4px solid #2196f3;
    }

    .ai-info strong {
      display: block;
      margin-bottom: 4px;
      font-size: 14px;
    }

    .turn-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 30px;
      border-radius: 16px;
      font-size: 20px;
      font-weight: 600;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .turn-indicator.show {
      opacity: 1;
    }

    .ai-thinking {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 12px;
      font-size: 16px;
      z-index: 999;
      display: none;
    }

    .ai-thinking.show {
      display: block;
    }

    .piece-count {
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #eee;
    }

    .piece-count span {
      font-size: 14px;
      font-weight: 600;
    }

    .white-count {
      color: #333;
    }

    .black-count {
      color: #111;
    }

    @media (min-width: 768px) {
      .container {
        max-width: 500px;
      }

      .board {
        max-width: 450px;
      }

      .btn {
        padding: 16px 12px;
        font-size: 15px;
      }

      .status h2 {
        font-size: 20px;
      }
    }

    @media (max-height: 700px) {
      .board {
        max-width: 350px;
      }

      .header,
      .rules-panel {
        padding: 12px;
      }

      .btn {
        padding: 12px 8px;
        font-size: 13px;
      }
    }

    @media (orientation: landscape) and (max-height: 500px) {
      body {
        padding: 8px;
      }

      .container {
        flex-direction: row;
        align-items: flex-start;
      }

      .board-container {
        flex: 0 0 auto;
        width: 60%;
      }

      .header {
        flex: 1;
        margin-left: 12px;
      }

      .rules-panel {
        display: none;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="status">
        <h2 id="statusTitle">–í–∞—à —Ö–æ–¥ (–ë–µ–ª—ã–µ)</h2>
        <div class="status-info" id="statusInfo">–í—ã–±–µ—Ä–∏—Ç–µ —à–∞—à–∫—É –¥–ª—è —Ö–æ–¥–∞</div>
        <div class="piece-count">
          <span class="white-count">–ë–µ–ª—ã–µ: <span id="whiteCount">21</span></span>
          <span class="black-count">–ß—ë—Ä–Ω—ã–µ: <span id="blackCount">21</span></span>
        </div>
      </div>

      <div class="controls">
        ¬† <button class="btn btn-primary" id="newBtn">
          ¬† ¬† <span></span> –ù–æ–≤–∞—è
          ¬† </button>
        ¬† <!-- –ö–Ω–æ–ø–∫–∞ "–û—Ç–º–µ–Ω–∞" —É–¥–∞–ª–µ–Ω–∞ -->
        ¬† <button class="btn btn-success" id="aiLevelBtn">
          ¬† ¬† <span></span> AI: –°–∏–ª—å–Ω—ã–π
          ¬† </button>
      </div>
    </div>

    <div class="board-container">
      <div id="board" class="board"></div>
      <div class="ai-thinking" id="aiThinking">AI –¥—É–º–∞–µ—Ç...</div>
    </div>

    <div class="rules-panel">
      <button class="rules-toggle" id="rulesToggle">
        <span>üìñ –ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã</span>
        <span id="rulesArrow">‚ñº</span>
      </button>

      <div class="rules-content" id="rulesContent">
        <ul>
          <li><strong>–î–æ—Å–∫–∞ 7√ó8</strong> –∫–ª–µ—Ç–æ–∫</li>
          <li>–ù–∞—á–∞–ª—å–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞: –ø–æ 21 —à–∞—à–∫–µ —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã</li>
          <li>–û–±—ã—á–Ω–∞—è —à–∞—à–∫–∞ —Ö–æ–¥–∏—Ç –≤–ø–µ—Ä—ë–¥ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –∏ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏</li>
          <li>–ë—å—ë—Ç –≤ 8 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è—Ö (–¥–∏–∞–≥–æ–Ω–∞–ª–∏ + –≤–µ—Ä—Ç–∏–∫–∞–ª—å + –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å)</li>
          <li>–î–∞–º–∫–∞ —Ö–æ–¥–∏—Ç –∫–∞–∫ —Ñ–µ—Ä–∑—å (–≤ –ª—é–±–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏)</li>
          <li>–í–∑—è—Ç–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ</li>
          <li>–ù–µ–ª—å–∑—è —Å–º–µ—à–∏–≤–∞—Ç—å —Ç–∏–ø—ã –≤–∑—è—Ç–∏—è –≤ –æ–¥–Ω–æ–º —Ö–æ–¥–µ</li>
          <li>–ü—Ä–µ–≤—Ä–∞—â–µ–Ω–∏–µ –≤ –¥–∞–º–∫—É –Ω–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–∏</li>
          <li> –ê–≤—Ç–æ—Ä—ã –∏–≥—Ä—ã Alex(brevis) & Judgen –ë–µ–ª–æ—É—Å–æ–≤—ã</li>
        </ul>

        <div class="ai-info">
          <strong>–°–∏–ª—å–Ω—ã–π AI:</strong>
          –ì–ª—É–±–æ–∫–∏–π –ø–æ–∏—Å–∫ (4-5 —Ö–æ–¥–æ–≤), –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞, –∫–æ–Ω—Ç—Ä–æ–ª—å —Ü–µ–Ω—Ç—Ä–∞, –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–∞–º–∫–∞–º
        </div>
      </div>
    </div>

    <div class="turn-indicator" id="turnIndicator">–•–æ–¥ AI</div>
  </div>

  <script>
    /**********************************************************************
     * –ú–æ–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è —à–∞—à–µ–∫ 7x8 —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–µ–π –¥–ª—è Android
     **********************************************************************/
    const COLS = 7; // 7 –≤–µ—Ä—Ç–∏–∫–∞–ª–µ–π
    const ROWS = 8; // 8 –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª–µ–π

    const state = {
      board: null,
      turn: "w",
      selected: null,
      legalMoves: [],
      hints: new Map(),
      busy: false,
      history: [],
      aiLevel: "strong",
      touchStart: null
    };

    // DOM —ç–ª–µ–º–µ–Ω—Ç—ã
    const boardEl = document.getElementById("board");
    const statusTitle = document.getElementById("statusTitle");
    const statusInfo = document.getElementById("statusInfo");
    const whiteCountEl = document.getElementById("whiteCount");
    const blackCountEl = document.getElementById("blackCount");
    const newBtn = document.getElementById("newBtn");
    const aiLevelBtn = document.getElementById("aiLevelBtn");
    const aiThinking = document.getElementById("aiThinking");
    const turnIndicator = document.getElementById("turnIndicator");
    const rulesToggle = document.getElementById("rulesToggle");
    const rulesContent = document.getElementById("rulesContent");
    const rulesArrow = document.getElementById("rulesArrow");

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
    function cloneBoard(board) {
      return board.map(row => row.map(cell => cell ? ({ ...cell }) : null));
    }

    function inBounds(r, c) {
      return r >= 0 && r < ROWS && c >= 0 && c < COLS;
    }

    function forwardDir(player) {
      return player === "w" ? -1 : +1;
    }

    function cellKey(r, c) {
      return `${r},${c}`;
    }

    // –ù–∞—á–∞–ª—å–Ω–∞—è —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞
    function initialBoard() {
      const b = Array.from({ length: ROWS }, () => Array(COLS).fill(null));

      // –ß—ë—Ä–Ω—ã–µ —à–∞—à–∫–∏ (–≤–µ—Ä—Ö–Ω–∏–µ 3 —Ä—è–¥–∞)
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < COLS; c++) {
          b[r][c] = { p: "b", k: false };
        }
      }

      // –ë–µ–ª—ã–µ —à–∞—à–∫–∏ (–Ω–∏–∂–Ω–∏–µ 3 —Ä—è–¥–∞)
      for (let r = ROWS - 3; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          b[r][c] = { p: "w", k: false };
        }
      }

      return b;
    }

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –¥–æ—Å–∫–∏
    function render() {
      boardEl.innerHTML = "";

      // –ü–æ–¥—Å—á–µ—Ç —à–∞—à–µ–∫
      let whiteCount = 0, blackCount = 0;

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const sq = document.createElement("div");
          sq.className = "sq";
          sq.dataset.r = r;
          sq.dataset.c = c;

          // –ü–æ–¥—Å—á–µ—Ç —à–∞—à–µ–∫
          const piece = state.board[r][c];
          if (piece) {
            if (piece.p === "w") whiteCount++;
            else blackCount++;
          }

          // –í—ã–¥–µ–ª–µ–Ω–∏–µ –∏ –ø–æ–¥—Å–∫–∞–∑–∫–∏
          if (state.selected && state.selected.r === r && state.selected.c === c) {
            sq.classList.add("sel");
          }
          if (state.hints.has(cellKey(r, c))) {
            sq.classList.add("hint");
          }

          const mv = state.hints.get(cellKey(r, c));
          if (mv && mv.captures.length > 0) {
            sq.classList.add("capHint");
          }

          // –®–∞—à–∫–∞
          if (piece) {
            const p = document.createElement("div");
            p.className = `piece ${piece.p === "w" ? "white" : "black"}${piece.k ? " king" : ""}`;
            sq.appendChild(p);
          }

          boardEl.appendChild(sq);
        }
      }

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—á–µ—Ç—á–∏–∫–æ–≤
      whiteCountEl.textContent = whiteCount;
      blackCountEl.textContent = blackCount;

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
      const outcome = getOutcome(state.board, state.turn);
      if (outcome.over) {
        statusTitle.textContent = "–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞";
        statusInfo.textContent = outcome.message;
      } else {
        if (state.turn === "w") {
          statusTitle.textContent = "–í–∞—à —Ö–æ–¥ (–ë–µ–ª—ã–µ)";
          statusInfo.textContent = state.selected
            ? "–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–µ—Ç–∫—É –¥–ª—è —Ö–æ–¥–∞"
            : "–í—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ—é —à–∞—à–∫—É";
        } else {
          statusTitle.textContent = "–•–æ–¥ AI (–ß—ë—Ä–Ω—ã–µ)";
          statusInfo.textContent = "AI –æ–±–¥—É–º—ã–≤–∞–µ—Ç —Ö–æ–¥...";
        }
      }

      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–Ω–æ–ø–æ–∫
    }

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ª–µ–≥–∞–ª—å–Ω—ã—Ö —Ö–æ–¥–æ–≤
    function updateLegalMoves() {
      state.legalMoves = getLegalMoves(state.board, state.turn);
      state.selected = null;
      state.hints.clear();
      render();
    }

    // Touch —Å–æ–±—ã—Ç–∏—è –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
    boardEl.addEventListener("touchstart", (e) => {
      if (state.busy) return;
      e.preventDefault();
      const touch = e.touches[0];
      const target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (!target || !target.classList.contains("sq")) return;

      state.touchStart = { time: Date.now(), target };

      // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –æ—Ç–ª–∏—á–∏—è —Ç–∞–ø–∞ –æ—Ç —Å–≤–∞–π–ø–∞
      setTimeout(() => {
        if (state.touchStart && state.touchStart.target === target) {
          handleCellClick(target);
        }
      }, 150);
    });

    boardEl.addEventListener("touchmove", (e) => {
      // –û—Ç–º–µ–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –∫–ª–∏–∫–∞ –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –ø–∞–ª—å—Ü–∞
      state.touchStart = null;
    });

    boardEl.addEventListener("touchend", (e) => {
      state.touchStart = null;
    });

    // –ö–ª–∏–∫ –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–æ–≤ –∏ –∫–∞–∫ fallback
    boardEl.addEventListener("click", (e) => {
      if (state.busy) return;
      const target = e.target.closest(".sq");
      if (!target) return;

      handleCellClick(target);
    });

    function handleCellClick(target) {
      const r = parseInt(target.dataset.r);
      const c = parseInt(target.dataset.c);

      const outcome = getOutcome(state.board, state.turn);
      if (outcome.over) return;
      if (state.turn !== "w") return;

      const mv = state.hints.get(cellKey(r, c));
      if (mv) {
        // –•–æ–¥ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –∫–ª–µ—Ç–∫—É
        //state.history = [cloneBoard(state.board)];
        state.board = applyMove(state.board, mv);
        state.turn = "b";
        state.selected = null;
        state.hints.clear();
        updateLegalMoves();

        // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ö–æ–¥–∞ AI
        showTurnIndicator();
        setTimeout(() => aiTurn(), 500);
        return;
      }

      const piece = state.board[r][c];
      if (!piece || piece.p !== "w") return;

      // –í—ã–±–æ—Ä —à–∞—à–∫–∏
      state.selected = { r, c };
      state.hints.clear();

      const movesFromHere = state.legalMoves.filter(m =>
        m.from.r === r && m.from.c === c
      );

      for (const m of movesFromHere) {
        const to = m.path[m.path.length - 1];
        state.hints.set(cellKey(to.r, to.c), m);
      }

      render();
    }

    // –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ö–æ–¥–∞ AI
    function showTurnIndicator() {
      turnIndicator.classList.add("show");
      setTimeout(() => {
        turnIndicator.classList.remove("show");
      }, 1000);
    }

    // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    newBtn.addEventListener("click", () => {
      startGame();
      // –í–∏–±—Ä–æ–æ—Ç–∫–ª–∏–∫ –Ω–∞ Android
      if (navigator.vibrate) navigator.vibrate(50);
    });
    aiLevelBtn.addEventListener("click", () => {
      state.aiLevel = state.aiLevel === "normal" ? "strong" : "normal";
      aiLevelBtn.innerHTML = state.aiLevel === "normal"
        ? '<span>ü§ñ</span> AI: –û–±—ã—á–Ω—ã–π'
        : '<span>ü§ñ</span> AI: –°–∏–ª—å–Ω—ã–π';
      aiLevelBtn.className = state.aiLevel === "normal"
        ? "btn btn-secondary"
        : "btn btn-success";
      if (navigator.vibrate) navigator.vibrate(30);
    });

    rulesToggle.addEventListener("click", () => {
      rulesContent.classList.toggle("show");
      rulesArrow.textContent = rulesContent.classList.contains("show") ? "‚ñ≤" : "‚ñº";
      if (navigator.vibrate) navigator.vibrate(30);
    });

    /**********************************************************************
     * –õ–æ–≥–∏–∫–∞ –∏–≥—Ä—ã (–æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, —Ç–æ–ª—å–∫–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ)
     **********************************************************************/

    function mkMove(fromR, fromC, path, captures) {
      return { from: { r: fromR, c: fromC }, path, captures };
    }

    function getLegalMoves(board, player) {
      const captures = [];
      const normals = [];

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const piece = board[r][c];
          if (!piece || piece.p !== player) continue;

          const caps = piece.k
            ? genKingCaptures(board, r, c, player)
            : genManCaptures(board, r, c, player);

          captures.push(...caps);

          if (caps.length === 0) {
            const ms = piece.k
              ? genKingMoves(board, r, c)
              : genManMoves(board, r, c, player);
            normals.push(...ms);
          }
        }
      }

      return captures.length ? captures : normals;
    }

    function genManMoves(board, r, c, player) {
      const res = [];
      const dr = forwardDir(player);

      for (const dc of [-1, +1]) {
        const nr = r + dr, nc = c + dc;
        if (inBounds(nr, nc) && board[nr][nc] === null) {
          res.push(mkMove(r, c, [{ r: nr, c: nc }], []));
        }
      }

      const nr = r + dr, nc = c;
      if (inBounds(nr, nc) && board[nr][nc] === null) {
        res.push(mkMove(r, c, [{ r: nr, c: nc }], []));
      }

      return res;
    }

    function genKingMoves(board, r, c) {
      const res = [];
      const dirs = [
        [-1, -1], [-1, +1], [+1, -1], [+1, +1],
        [-1, 0], [+1, 0], [0, -1], [0, +1]
      ];

      for (const [dr, dc] of dirs) {
        let nr = r + dr, nc = c + dc;
        while (inBounds(nr, nc) && board[nr][nc] === null) {
          res.push(mkMove(r, c, [{ r: nr, c: nc }], []));
          nr += dr; nc += dc;
        }
      }

      return res;
    }

    function genManCaptures(board, r, c, player) {
      const startPiece = board[r][c];
      if (!startPiece) return [];
      const res = [];

      const dirs8 = [
        [-1, -1], [-1, +1], [+1, -1], [+1, +1],
        [-1, 0], [+1, 0], [0, -1], [0, +1]
      ];

      function dfs(b, cr, cc, piece, path, caps, mode) {
        let any = false;
        const curPiece = maybePromote(piece, cr, player);

        if (curPiece.k) {
          const steps = genKingCaptureSteps(b, cr, cc, player, mode);
          for (const step of steps) {
            any = true;
            const nextMode = mode || step.mode;
            const nb = applyQueenCaptureStep(b, cr, cc, step, curPiece);
            dfs(nb.board, step.to.r, step.to.c, nb.movedPiece,
              [...path, step.to], [...caps, step.cap], nextMode);
          }
        } else {
          for (const [dr, dc] of dirs8) {
            const dirMode = (dr !== 0 && dc !== 0) ? "diag" : "ortho";
            if (mode && dirMode !== mode) continue;

            const mr = cr + dr, mc = cc + dc;
            const lr = cr + 2 * dr, lc = cc + 2 * dc;
            if (!inBounds(lr, lc) || !inBounds(mr, mc)) continue;

            const mid = b[mr][mc];
            if (mid && mid.p !== player && b[lr][lc] === null) {
              any = true;
              const nb = cloneBoard(b);
              nb[cr][cc] = null;
              nb[mr][mc] = null;
              const moved = { ...curPiece };
              nb[lr][lc] = moved;
              dfs(nb, lr, lc, moved, [...path, { r: lr, c: lc }],
                [...caps, { r: mr, c: mc }], dirMode);
            }
          }
        }

        if (!any && caps.length > 0) {
          res.push(mkMove(r, c, path, caps));
        }
      }

      dfs(cloneBoard(board), r, c, { ...startPiece }, [], [], null);
      return res;
    }

    function genKingCaptures(board, r, c, player) {
      const startPiece = board[r][c];
      if (!startPiece) return [];
      const res = [];

      function dfs(b, cr, cc, piece, path, caps, mode) {
        let any = false;
        const steps = genKingCaptureSteps(b, cr, cc, player, mode);

        for (const step of steps) {
          any = true;
          const nextMode = mode || step.mode;
          const nb = applyQueenCaptureStep(b, cr, cc, step, piece);
          dfs(nb.board, step.to.r, step.to.c, nb.movedPiece,
            [...path, step.to], [...caps, step.cap], nextMode);
        }

        if (!any && caps.length > 0) {
          res.push(mkMove(r, c, path, caps));
        }
      }

      dfs(cloneBoard(board), r, c, { ...startPiece }, [], [], null);
      return res;
    }

    function genKingCaptureSteps(board, r, c, player, mode) {
      const dirs8 = [
        [-1, -1], [-1, +1], [+1, -1], [+1, +1],
        [-1, 0], [+1, 0], [0, -1], [0, +1]
      ];

      const steps = [];

      for (const [dr, dc] of dirs8) {
        const dirMode = (dr !== 0 && dc !== 0) ? "diag" : "ortho";
        if (mode && dirMode !== mode) continue;

        let nr = r + dr, nc = c + dc;
        let seenEnemy = null;

        while (inBounds(nr, nc)) {
          const cell = board[nr][nc];
          if (cell === null) {
            if (seenEnemy) {
              steps.push({ cap: seenEnemy, to: { r: nr, c: nc }, mode: dirMode });
            }
          } else {
            if (cell.p === player) break;
            if (seenEnemy) break;
            seenEnemy = { r: nr, c: nc };
          }
          nr += dr; nc += dc;
        }
      }

      return steps;
    }

    function applyQueenCaptureStep(board, fromR, fromC, step, piece) {
      const nb = cloneBoard(board);
      nb[fromR][fromC] = null;
      nb[step.cap.r][step.cap.c] = null;
      const movedPiece = { ...piece };
      nb[step.to.r][step.to.c] = movedPiece;
      return { board: nb, movedPiece };
    }

    function maybePromote(piece, r, player) {
      if (piece.k) return piece;
      const lastRow = player === "w" ? 0 : ROWS - 1;
      if (r === lastRow) return { ...piece, k: true };
      return piece;
    }

    function applyMove(board, move) {
      const nb = cloneBoard(board);
      const from = move.from;
      const piece = nb[from.r][from.c];
      nb[from.r][from.c] = null;

      for (const cap of move.captures) nb[cap.r][cap.c] = null;

      const last = move.path[move.path.length - 1];
      let moved = { ...piece };
      moved = maybePromote(moved, last.r, moved.p);

      nb[last.r][last.c] = moved;
      return nb;
    }

    function countPieces(board, player) {
      let n = 0;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const p = board[r][c];
          if (p && p.p === player) n++;
        }
      }
      return n;
    }

    function getOutcome(board, turn) {
      const moves = getLegalMoves(board, turn);
      const wCount = countPieces(board, "w");
      const bCount = countPieces(board, "b");

      if (wCount === 0) return { over: true, message: "–ü–æ–±–µ–¥–∏–ª AI (—á—ë—Ä–Ω—ã–µ)" };
      if (bCount === 0) return { over: true, message: "–í—ã –ø–æ–±–µ–¥–∏–ª–∏! (–±–µ–ª—ã–µ)" };
      if (moves.length === 0) {
        return {
          over: true,
          message: turn === "w"
            ? "–£ –≤–∞—Å –Ω–µ—Ç —Ö–æ–¥–æ–≤. –ü–æ–±–µ–¥–∏–ª AI"
            : "–£ AI –Ω–µ—Ç —Ö–æ–¥–æ–≤. –í—ã –ø–æ–±–µ–¥–∏–ª–∏!"
        };
      }
      return { over: false, message: "" };
    }

    /**********************************************************************
     * –£—Å–∏–ª–µ–Ω–Ω—ã–π AI (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö)
     **********************************************************************/

    const POSITION_WEIGHTS = [
      [0, 0, 0, 0, 0, 0, 0],
      [1, 2, 3, 4, 3, 2, 1],
      [1, 2, 3, 4, 3, 2, 1],
      [1, 2, 3, 5, 3, 2, 1],
      [1, 2, 3, 5, 3, 2, 1],
      [1, 2, 3, 4, 3, 2, 1],
      [1, 2, 3, 4, 3, 2, 1],
      [0, 0, 0, 0, 0, 0, 0],
    ];

    const KING_POSITION_WEIGHTS = [
      [0, 0, 0, 0, 0, 0, 0],
      [1, 1, 2, 3, 2, 1, 1],
      [2, 2, 3, 4, 3, 2, 2],
      [3, 3, 4, 5, 4, 3, 3],
      [3, 3, 4, 5, 4, 3, 3],
      [2, 2, 3, 4, 3, 2, 2],
      [1, 1, 2, 3, 2, 1, 1],
      [0, 0, 0, 0, 0, 0, 0],
    ];

    function evaluateEnhanced(board) {
      let score = 0;

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const pc = board[r][c];
          if (!pc) continue;

          let pieceValue = 0;

          if (pc.k) {
            pieceValue = 8;
            pieceValue += KING_POSITION_WEIGHTS[r][c] * 0.2;
            if (c >= 2 && c <= 4 && r >= 2 && r <= 5) pieceValue += 1;
          } else {
            pieceValue = 3;
            pieceValue += POSITION_WEIGHTS[r][c] * 0.3;

            if (pc.p === "b" && r >= ROWS - 3) pieceValue += 0.5 * (ROWS - r);
            if (pc.p === "w" && r <= 2) pieceValue += 0.5 * (r + 1);

            const backRow = pc.p === "b" ? r + 1 : r - 1;
            if (inBounds(backRow, c) && board[backRow][c] &&
              board[backRow][c].p === pc.p) pieceValue += 0.3;
          }

          for (const [dr, dc] of [[0, 1], [0, -1], [1, 0], [-1, 0],
          [1, 1], [1, -1], [-1, 1], [-1, -1]]) {
            const nr = r + dr, nc = c + dc;
            if (inBounds(nr, nc) && board[nr][nc] && board[nr][nc].p === pc.p) {
              pieceValue += 0.1;
            }
          }

          score += (pc.p === "b") ? pieceValue : -pieceValue;
        }
      }

      const mobilityB = getLegalMoves(board, "b").length;
      const mobilityW = getLegalMoves(board, "w").length;
      score += 0.1 * (mobilityB - mobilityW);

      let centerControlB = 0, centerControlW = 0;
      const centerCells = [[3, 3], [3, 4], [4, 3], [4, 4]];

      for (const [r, c] of centerCells) {
        if (board[r][c]) {
          if (board[r][c].p === "b") centerControlB += 2;
          else centerControlW += 2;
        }

        for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1],
        [-1, -1], [-1, 1], [1, -1], [1, 1]]) {
          const nr = r + dr, nc = c + dc;
          if (inBounds(nr, nc) && board[nr][nc]) {
            if (board[nr][nc].p === "b") centerControlB += 0.5;
            else centerControlW += 0.5;
          }
        }
      }

      score += 0.05 * (centerControlB - centerControlW);
      return score;
    }

    function evaluateSimple(board) {
      let score = 0;
      const mobilityB = getLegalMoves(board, "b").length;
      const mobilityW = getLegalMoves(board, "w").length;

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const pc = board[r][c];
          if (!pc) continue;
          const val = pc.k ? 6 : 3;
          score += (pc.p === "b") ? val : -val;
        }
      }

      score += 0.05 * (mobilityB - mobilityW);
      return score;
    }

    function minimax(board, player, depth, alpha, beta, maximizingPlayer) {
      const outcome = getOutcome(board, player);
      if (outcome.over) {
        if (outcome.message.includes("—á—ë—Ä–Ω—ã–µ")) return { score: 9999 + depth, move: null };
        if (outcome.message.includes("–±–µ–ª—ã–µ")) return { score: -9999 - depth, move: null };
      }

      if (depth === 0) {
        return {
          score: state.aiLevel === "strong" ? evaluateEnhanced(board) : evaluateSimple(board),
          move: null
        };
      }

      const moves = getLegalMoves(board, player);
      if (moves.length === 0) {
        return {
          score: state.aiLevel === "strong" ? evaluateEnhanced(board) : evaluateSimple(board),
          move: null
        };
      }

      let sortedMoves = moves;
      if (state.aiLevel === "strong" && depth > 2) {
        sortedMoves = [...moves].sort((a, b) => {
          const aCaptures = a.captures.length;
          const bCaptures = b.captures.length;
          if (aCaptures !== bCaptures) return bCaptures - aCaptures;

          const aPromotes = willPromote(a, player);
          const bPromotes = willPromote(b, player);
          return bPromotes - aPromotes;
        });
      }

      const isMax = maximizingPlayer;
      let bestMove = null;

      if (isMax) {
        let bestScore = -Infinity;
        for (const mv of sortedMoves) {
          const nb = applyMove(board, mv);
          const res = minimax(nb, player === "b" ? "w" : "b", depth - 1, alpha, beta, false);
          if (res.score > bestScore) {
            bestScore = res.score;
            bestMove = mv;
          }
          alpha = Math.max(alpha, bestScore);
          if (beta <= alpha) break;
        }
        return { score: bestScore, move: bestMove };
      } else {
        let bestScore = Infinity;
        for (const mv of sortedMoves) {
          const nb = applyMove(board, mv);
          const res = minimax(nb, player === "b" ? "w" : "b", depth - 1, alpha, beta, true);
          if (res.score < bestScore) {
            bestScore = res.score;
            bestMove = mv;
          }
          beta = Math.min(beta, bestScore);
          if (beta <= alpha) break;
        }
        return { score: bestScore, move: bestMove };
      }
    }

    function willPromote(move, player) {
      const last = move.path[move.path.length - 1];
      const lastRow = player === "w" ? 0 : ROWS - 1;
      return last.r === lastRow;
    }

    async function aiTurn() {
      const outcome = getOutcome(state.board, state.turn);
      if (outcome.over) {
        render();
        return;
      }

      state.busy = true;
      aiThinking.classList.add("show");
      render();

      // AI –¥—É–º–∞–µ—Ç —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π –¥–ª—è UX
      await new Promise(r => setTimeout(r, state.aiLevel === "strong" ? 800 : 400));

      const depth = state.aiLevel === "strong" ? 4 : 3;
      const { move } = minimax(state.board, "b", depth, -Infinity, Infinity, true);

      if (move) {
        state.board = applyMove(state.board, move);
        if (navigator.vibrate) navigator.vibrate(100);
      }

      state.turn = "w";
      state.busy = false;
      state.history = [];
      aiThinking.classList.remove("show");
      updateLegalMoves();
    }

    /**********************************************************************
     * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
     **********************************************************************/

    function startGame() {
      state.board = initialBoard();
      state.turn = "w";
      state.selected = null;
      state.hints.clear();
      state.history = [];
      updateLegalMoves();

      // –í–∏–±—Ä–æ–æ—Ç–∫–ª–∏–∫ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∏–≥—Ä—ã
      if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
    }

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–∞—Ä—Ç –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
    document.addEventListener("DOMContentLoaded", () => {
      startGame();

      // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
      document.addEventListener("touchmove", (e) => {
        if (e.scale !== 1) {
          e.preventDefault();
        }
      }, { passive: false });

      // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö
      document.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });
    });
  </script>
</body>

</html>